# 
# Copyright 2022 Chair of EDA, Technical University of Munich
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#       http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#!/usr/bin/env python3

import argparse
import pathlib
import pickle

from .CodeGenerator import CodeGenerator
from common import common as cf

# Class to keep folder-structure related information
class FileDict:

    def __init__(self, outDir_, modelName_):

        templateDir = pathlib.Path(__file__).parents[0] / "templates"
        outDir = outDir_ / modelName_

        self.dict={}
        self.dict["ChannelHeader"] = {  "Template" : templateDir / "channel/include/channel.mako",
                                        "OutFile" : cf.createOrReplaceDir(outDir / "channel/include") / (modelName_ + "_Channel.h")}
        self.dict["ChannelSource"] = {  "Template" : templateDir / "channel/src/channel.mako",
                                        "OutFile" : cf.createOrReplaceDir(outDir / "channel/src") / (modelName_ + "_Channel.cpp")}
        self.dict["MonitorHeader"] = {  "Template" : templateDir / "monitor/include/monitor.mako",
                                        "OutFile" : cf.createOrReplaceDir(outDir / "monitor/include") / (modelName_ + "_Monitor.h")}
        self.dict["MonitorSource"] = {  "Template" : templateDir / "monitor/src/monitor.mako",
                                        "OutFile" : cf.createOrReplaceDir(outDir / "monitor/src") / (modelName_ + "_Monitor.cpp")}
        self.dict["InstructionMonitorsSource"] = {  "Template" : templateDir / "monitor/src/instructionMonitors.mako",
                                        "OutFile" : self.dict["MonitorSource"]["OutFile"].parents[0] / (modelName_ + "_InstructionMonitors.cpp")}
        self.dict["PrinterHeader"] = {  "Template" : templateDir / "printer/include/printer.mako",
                                        "OutFile" : cf.createOrReplaceDir(outDir / "printer/include") / (modelName_ + "_Printer.h")}
        self.dict["PrinterSource"] = {  "Template" : templateDir / "printer/src/printer.mako",
                                        "OutFile" : cf.createOrReplaceDir(outDir / "printer/src") / (modelName_ + "_Printer.cpp")}
        self.dict["InstructionPrintersSource"] = {  "Template" : templateDir / "printer/src/instructionPrinters.mako",
                                        "OutFile" : self.dict["PrinterSource"]["OutFile"].parents[0] / (modelName_ + "_InstructionPrinters.cpp")}


    def getTemplate(self, name_):
        return self.__get(name_, "Template")

    def getOutFile(self, name_):
        return self.__get(name_, "OutFile")

    def __get(self, name_, type_):
        # TODO: Add error handling
        return self.dict[name_][type_]

def main(model_, outDir_):

    print()
    print("-- Creating file-dictionary --")
    fileDict = FileDict(outDir_, model_.name)

    # Constructiong code generator
    codeGen = CodeGenerator(model_, fileDict)

    print()
    print("-- Generating code for trace-channel --")
    codeGen.generate("ChannelHeader")
    
    print()
    print("-- Generating code for trace-monitor --")
    codeGen.generate("MonitorHeader")
    codeGen.generate("MonitorSource")
    codeGen.generate("InstructionMonitorsSource")

    print()
    print("-- Generating code for trace-printer --")
    codeGen.generate("PrinterHeader")
    codeGen.generate("PrinterSource")
    codeGen.generate("InstructionPrintersSource")
        

# Run this if called stand-alone (i.e. this file is directly called)
if __name__ == '__main__':

    # Parse command line arguments
    argParser = argparse.ArgumentParser()
    argParser.add_argument("model", help="File containing the trace-model (generated by Trace-Generator frontend)")
    argParser.add_argument("-o", "--outDir", help="Path to the output directory")
    args = argParser.parse_args()
    
    # Load model from file
    modelFile = pathlib.Path(args.model).resolve()
    if not modelFile.is_file():
        raise TypeError("Specified model (%s) does not exist!" % modelFile)
    with modelFile.open('rb') as f:
        model = pickle.load(f)

    # Evaluate output path
    outDir = cf.resolveOutDir(args.outDir)

    # Call main routine of monitor_gen backend
    main(model, outDir)
